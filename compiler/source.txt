asm
{
    #include "CPU.asm"
    entry code
    data@ data
code:
    push $32768
    call mm_init
    push $235
    call malloc_test
code_done:
    hlt
};

fun print(var i){
    asm{
        out %r0
    };
}


fun malloc_test(var n){
    var i = 2;
    var *result = 0;
    while(i < n){
        result = mm_malloc(i);
        i = i + 1;
    }
}

fun setBlockAllocated(var *blkPtr, var size, var isAllocated){
    *(blkPtr - 1) = isAllocated; // allocated flag in header
    *(blkPtr - 2) = size; // size flag in header
}

fun getBlockIsAllocated(var *blkPtr){
    return *(blkPtr - 1);
}

fun getBlockSize(var *blkPtr){
    return *(blkPtr - 2);
}

fun getBlockNext(var *blkPtr){
    return (blkPtr + *(blkPtr - 2) + 4);
}

fun mm_init(var size){
    var *dataAt = 2;
    var *blkPtr = (*dataAt) + 4;
    var newSize = size - 4;
    print(newSize);

    setBlockAllocated(blkPtr, newSize, 0);
    print(blkPtr);
    return 0;
}

fun mm_malloc(var size){
    //print(size);
    var *dataAt = 2;
    var blkRunner = (*dataAt) + 4;
    var one = 1;
    while(one == 1){
        if(getBlockIsAllocated(blkRunner) == 0){
            if(getBlockSize(blkRunner) >= size){
                var newSize = (getBlockSize(blkRunner) - size) - 4;
                setBlockAllocated(blkRunner, size, 1);
                var *newBlk = blkRunner + size + 4;
                setBlockAllocated(newBlk, newSize, 0);
                return blkRunner;
            }else{
                asm{
                    hlt
                };
                blkRunner = getBlockNext(blkRunner);
            }
        }else{
            blkRunner = getBlockNext(blkRunner);
        }
    }
}


$$
